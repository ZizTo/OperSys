
## Поведенческие шаблоны проектирования

### 1. Шаблон "Состояние" (State)

**Определение:** Поведенческий паттерн, позволяющий объекту изменять свое поведение в зависимости от внутреннего состояния. Создается впечатление, что объект меняет свой класс.

**Примеры использования:**
1. **Проблема/Решение:** Управление состоянием документа (черновик, на рассмотрении, опубликован). Решение: вместо множества условных операторов, каждое состояние представляется отдельным классом с собственной реализацией операций.

2. **Проблема/Решение:** Торговый автомат с различными состояниями (ожидание монеты, выбор товара, выдача товара). Решение: изменение логики происходит через переключение между объектами состояний.

3. **Проблема/Решение:** Мультимедиа плеер с состояниями (остановлен, воспроизведение, пауза). Решение: каждое состояние инкапсулирует свое поведение для методов play(), stop(), pause().

**Через призму принципов:**
- **Инкапсуляция:** Каждое состояние инкапсулирует собственное поведение, скрывая детали реализации.
- **Разделяй и властвуй:** Разделение сложного поведения объекта на независимые классы состояний.
- **Ортогональные стратегии:** Состояния можно добавлять и модифицировать независимо от контекста.

**Многопоточность:** В многопоточной среде требуется синхронизация при смене состояний. Возможны гонки данных, если несколько потоков пытаются изменить состояние одновременно. Рекомендуется использовать атомарные операции или блокировки при смене состояний.

### 2. Шаблон "Посредник" (Mediator)

**Определение:** Паттерн, определяющий объект, инкапсулирующий взаимодействие множества объектов. Уменьшает связанность компонентов системы, заставляя их общаться косвенно через посредника.

**Примеры использования:**
1. **Проблема/Решение:** Управление взаимодействием элементов пользовательского интерфейса. Решение: Посредник координирует взаимодействие между кнопками, полями ввода и другими UI-элементами.

2. **Проблема/Решение:** Система управления воздушным движением. Решение: Диспетчерская башня (посредник) координирует взаимодействие между самолетами без их прямого общения.

3. **Проблема/Решение:** Чат-приложение. Решение: Сервер выступает посредником, принимая и перенаправляя сообщения между пользователями.

**Через призму принципов:**
- **Инкапсуляция:** Логика взаимодействия инкапсулирована в посреднике.
- **Разделяй и властвуй:** Посредник разделяет логику взаимодействия от бизнес-логики компонентов.
- **Ортогональные стратегии:** Компоненты могут развиваться независимо, зная только о посреднике.

**Многопоточность:** Посредник может стать узким местом в многопоточной системе. Требуется тщательная синхронизация для предотвращения блокировок и состояний гонки. Потенциально посредник может быть реализован как асинхронный компонент с очередью сообщений.

### 3. Шаблон "Наблюдатель" (Observer)

**Определение:** Поведенческий паттерн, создающий механизм подписки, позволяющий одним объектам (наблюдателям) следить и реагировать на события, происходящие в других объектах (субъектах).

**Примеры использования:**
1. **Проблема/Решение:** Обновление представлений при изменении модели данных (MVC). Решение: Представления подписываются на изменения модели и автоматически обновляются.

2. **Проблема/Решение:** Система событий в GUI-приложениях. Решение: Элементы интерфейса генерируют события, а обработчики подписываются на них.

3. **Пример из библиотеки Qt:** Система сигналов и слотов в Qt является реализацией паттерна "Наблюдатель". Например, `connect(button, SIGNAL(clicked()), this, SLOT(handleClick()))` — кнопка (субъект) отправляет сигнал, а слот handleClick() (наблюдатель) реагирует на это событие.

**Через призму принципов:**
- **Инкапсуляция:** Наблюдатели и субъекты не знают деталей реализации друг друга.
- **Разделяй и властвуй:** Разделение логики генерации событий от обработки этих событий.
- **Ортогональные стратегии:** Наблюдатели могут подписываться и отписываться независимо друг от друга.

**Многопоточность:** В многопоточной среде шаблон "Наблюдатель" требует осторожности. Необходимо обеспечить синхронизацию при добавлении/удалении наблюдателей и оповещении. Qt решает эту проблему с помощью механизма очередей событий и сигналов/слотов с разными типами соединений (direct, queued).

## Что такое дизайн ПО

Дизайн программного обеспечения — это процесс определения архитектуры, компонентов, интерфейсов и других характеристик системы. Это процесс трансформации требований пользователя в подходящую форму для реализации разработчиками.

Ключевые аспекты дизайна ПО:
- Определение структуры системы (архитектура)
- Определение компонентов и их взаимодействия
- Проектирование интерфейсов
- Определение уровней абстракции
- Выбор паттернов проектирования
- Обеспечение качественных характеристик (поддерживаемость, расширяемость, тестируемость)

**Влияние многопоточности на дизайн ПО:**

1. **Изменение архитектуры:** Необходимость разделения системы на потокобезопасные компоненты, введение синхронизации.

2. **Увеличение сложности:** Многопоточный дизайн значительно усложняет систему, требует учета состояний гонки, взаимоблокировок, голоданий.

3. **Иммутабельность и функциональный подход:** Тенденция к использованию неизменяемых структур данных и функционального программирования для безопасного параллельного выполнения.

4. **Асинхронные модели:** Переход к реактивному программированию, событийным моделям и неблокирующему вводу-выводу.

5. **Использование очередей и акторов:** Тенденция к моделям "передачи сообщений" вместо прямого разделения памяти.

6. **Паттерны для многопоточности:** Появление специфических паттернов (Thread Pool, Producer-Consumer, Read-Write Lock).

7. **Ограниченная связность:** Усиление требований к слабой связанности компонентов для минимизации совместного использования состояния.

Многопоточность требует совершенно другого мышления при проектировании, смещая фокус с последовательного выполнения операций на параллельное исполнение и эффективную синхронизацию.
