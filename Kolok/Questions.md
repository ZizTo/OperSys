# Матиевский Павел - 9 группа - 1 вариант
## Первая часть
1. Для выполнения лабораторной работы 3 я использовал такие функции, как CreateThread для создания потоков, ExitThread для завершения потока, Sleep для приостановки выполнения. Также я использовал функции для синхронизации потопков: WaitForMultipleObject, InitializeCriticalSection, EnterCriticalSection, LeaveCriticalSection, DeleteCriticalSection
2. Для примера предалагю обратиться к [lab1](/Lab1.1). Потоком в Windows называется объект ядра, которому операционная система выделяет процессорное время для выполнения приложения. Каждому потоку принадлежат следующие ресурсы:
   - код исполняемой функции;
   - набор регистров процессора;
   - стек для работы приложения;
   - стек для работы операционной системы;
   - блок окружения, который содержит служебную информацию для работы потока.
3. Для примера предалагю обратиться к [lab3](/lab3). Для решения проблемы взаимного исключения между параллельными потоками, выполняющимися в контексте разных процессов, в операционных системах Windows используется объект ядра мьютекс. Особенности мьютексов:
   - Только один поток может владеть мьютексом в любой момент времени.
   - Если мьютекс занят, другие потоки блокируются до его освобождения.
   - В Windows используются функции:
       - CreateMutex() — создание.
       - WaitForSingleObject() — захват.
       - ReleaseMutex() — освобождение. 
4. Для примера предалагю обратиться к [lab1](/lab3). Событием называется оповещение о некотором выполненном действии. В программировании события используются для оповещения одного потока о том, что другой поток выполнил некоторое действие.
5. C++11 представляет значительный шаг вперед по сравнению с C++98, особенно в контексте многопоточности и синхронизации, что непосредственно относится к тематике лабораторных работ.
Особенности для с++98:
Многопоточность	Отсутствует стандартная поддержка многопоточности. Требуются платформозависимые библиотеки (POSIX threads, Windows threads)
Синхронизация	Отсутствует в стандартной библиотеке. Необходимы платформозависимые решения
Память и управление ресурсами	auto_ptr (устаревший), ручное управление памятью
Лямбда-выражения	Отсутствуют. Необходимо использовать функторы
Вывод типов	Ограниченный (в шаблонах)
Инициализация	Ограниченные возможности
Осбенности для с++11:
Многопоточность Введена стандартная библиотека многопоточности (std::thread, std::mutex, std::condition_variable)
Синхронизация Стандартные механизмы синхронизации: мьютексы, условные переменные, атомарные операции
Память и управление ресурсами unique_ptr, shared_ptr, weak_ptr, move-семантика
Лямбда-выражения Поддержка анонимных функций (лямбда-выражений)
Вывод типов Расширенный с помощью auto, decltype
Инициализация Унифицированная инициализация с использованием фигурных скобок {}
## Вторая часть
1. Что такое ООП? – полное определение
Объектно-ориентированное программирование (ООП) – это парадигма программирования, основанная на концепции "объектов", которые могут содержать данные в виде полей (также называемых атрибутами или свойствами) и код в виде процедур (также называемых методами). Основными принципами ООП являются:

- Абстракция – выделение существенных характеристик объекта, которые отличают его от всех других видов объектов, четко определяя его концептуальные границы.
- Инкапсуляция – механизм, объединяющий данные и методы, работающие с этими данными, защищая и то, и другое от внешнего вмешательства и неправильного использования.
- Наследование – механизм, позволяющий создавать новые классы на основе существующих, заимствуя их функциональность и добавляя новую.
- Полиморфизм – способность объекта принимать разные формы и вести себя по-разному в зависимости от контекста, что позволяет использовать один и тот же интерфейс для разных базовых классов.
- ООП также включает такие концепции, как классы, объекты, интерфейсы, делегирование, модульность и множественное наследование, в зависимости от реализации в конкретном языке программирования.

2. Магическое число 7 Миллера? – примеры из IT
Магическое число 7 Миллера – это психологическая концепция, предложенная Джорджем Миллером в 1956 году, согласно которой кратковременная память человека может удерживать одновременно примерно 7±2 элементов информации. В IT эта концепция находит следующие применения:

- Проектирование пользовательского интерфейса – оптимальное количество элементов меню или опций должно быть около 7, чтобы пользователи могли легко запомнить и выбрать нужный пункт.

- Структура навигации – рекомендуется не делать более 7 основных разделов на сайте или в приложении для лучшего восприятия пользователями.

- Телефонные номера – традиционно разбиваются на группы по 3-4 цифры, чтобы облегчить запоминание (например, XXX-XXX-XXXX в США).

- Количество параметров функций – хорошей практикой считается ограничение количества параметров функции до 7 или меньше для удобства использования и понимания.

- Уровни вложенности – рекомендуется не превышать 7 уровней вложенности в иерархических структурах данных или организации кода.

- Цветовые схемы – часто ограничиваются 5-9 базовыми цветами в пользовательском интерфейсе для лучшего восприятия и запоминания.

- Структура документации – разделение информации на 5-9 основных разделов для более эффективного усвоения материала.

- Количество шагов в процессе – оптимальное количество шагов в процессе регистрации, оформления заказа или других пользовательских процессах часто ограничивают 5-7 шагами.

3. Энтропия ПО – негэнтропийные меры при разработке ПО
Энтропия программного обеспечения – это мера беспорядка, сложности и непредсказуемости в программных системах, которая естественным образом увеличивается со временем. Негэнтропийные меры – это практики, которые помогают уменьшить или контролировать эту энтропию:

- Рефакторинг кода – регулярная переработка существующего кода без изменения его функциональности для улучшения внутренней структуры, что снижает сложность и улучшает понимание.

- Стандарты кодирования – применение единых правил оформления кода, именования переменных и функций, что делает код более последовательным и понятным.

- Модульное проектирование – разделение системы на независимые модули с четкими интерфейсами, что уменьшает связность и сложность.

- Автоматическое тестирование – разработка модульных, интеграционных и регрессионных тестов, которые помогают выявлять и предотвращать деградацию кода.

- Документирование кода – создание и поддержание актуальной документации, которая объясняет архитектуру, дизайн и детали реализации системы.

- Непрерывная интеграция/непрерывное развертывание (CI/CD) – автоматизация процессов сборки, тестирования и выпуска ПО, что обеспечивает стабильность и предсказуемость.

- Управление техническим долгом – систематическое выявление и устранение проблем кода, которые накапливаются со временем.

4. 5 признаков сложной системы по Гради Бучу
По Гради Бучу, сложные системы характеризуются следующими признаками:

- Иерархическая структура

   - Пример 1: В моём проекте веб-приложения архитектура включала несколько уровней: презентационный уровень (React-компоненты), уровень бизнес-логики (сервисы), уровень доступа к данным (репозитории) и уровень базы данных (SQL Server).
   - Пример 2: В мобильном приложении, которое я разрабатывал, использовалась иерархия компонентов: контейнеры верхнего уровня → экраны → блоки интерфейса → базовые UI-компоненты.
- Относительная примитивность базовых компонентов

   - Пример 1: В лабораторной работе по ООП я создал базовый класс Shape с простыми свойствами (координаты, цвет), от которого наследовались более сложные фигуры (круг, квадрат, многоугольник).
   - Пример 2: В проекте парсера данных я использовал простые атомарные функции для обработки строк, которые затем объединялись в более сложные алгоритмы анализа документов.
- Разделение на классы и объекты

   - Пример 1: В проекте системы управления библиотекой я создал классы Book, User, Loan и т.д., а затем работал с конкретными экземплярами этих классов.
   - Пример 2: В лабораторной работе по моделированию транспортной системы были определены абстрактные классы транспортных средств и маршрутов, на основе которых создавались конкретные объекты (автобус №54, маршрут A→B).
- Сильные связи внутри подсистем и слабые между подсистемами

   - Пример 1: В проекте e-commerce система обработки платежей была сильно связана внутри себя, но взаимодействовала с системой управления заказами только через четко определенный API.
   - Пример 2: В лабораторной работе по разработке игры модуль физики имел сложные внутренние зависимости, но взаимодействовал с модулем рендеринга только через интерфейс IPhysicsObject.
- Эволюционное развитие

   - Пример 1: Мой pet-проект менеджера задач начинался с простого приложения для списка дел, но постепенно эволюционировал, добавляя функции категорий, приоритетов, повторяющихся задач и интеграции с календарем.
   - Пример 2: В лабораторной работе по базам данных изначальная схема с 3 таблицами постепенно расширилась до 12 таблиц по мере того, как добавлялись новые требования и функциональность.
5. Закон иерархических компенсаций Седова
Закон иерархических компенсаций Седова гласит, что в сложной иерархической системе при повышении уровня организации (увеличении разнообразия, сложности) на верхнем уровне иерархии неизбежно упрощение организации (уменьшение разнообразия) на нижних уровнях, и наоборот. Примеры в эволюции IT сферы:

- Высокоуровневые языки программирования и абстракции: Появление языков программирования высокого уровня (Python, JavaScript) позволило упростить разработку сложных систем, но ценой потери контроля над низкоуровневыми деталями исполнения (управление памятью, оптимизация на уровне инструкций процессора).

- Виртуализация и контейнеризация: Технологии виртуализации (VMware, VirtualBox) и контейнеризации (Docker, Kubernetes) предоставили высокоуровневые инструменты для управления инфраструктурой, но ограничили прямой доступ к аппаратным ресурсам и требуют стандартизации низкоуровневых компонентов.

- Фреймворки и библиотеки: Развитие фреймворков (React, Django, Spring) упростило разработку сложных приложений, но ценой навязывания определенной структуры и ограничения свободы в выборе архитектурных решений на нижних уровнях.

- Облачные технологии: Облачные сервисы (AWS, Azure, Google Cloud) предоставили простые интерфейсы для сложных задач (масштабирование, отказоустойчивость), но потребовали стандартизации низкоуровневых компонентов и ограничили возможности тонкой настройки инфраструктуры.

- Абстракции баз данных: ORM-системы (Hibernate, Entity Framework, SQLAlchemy) упростили работу с базами данных на высоком уровне, но ограничили возможности использования специфических особенностей конкретных СУБД и оптимизации запросов на низком уровне.

- Методологии разработки: Agile-методологии предоставили гибкие инструменты для управления сложными проектами, но потребовали стандартизации и формализации процессов разработки на уровне команд и отдельных разработчиков.
